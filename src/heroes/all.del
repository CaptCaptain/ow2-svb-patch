import '../../../OSTWUtils/Miscellaneous.del';
import '../../../OSTWUtils/OnScreenText.del';
import '../../../OSTWUtils/EasingFunctions.del';

playervar Number SupportHealingID;
playervar Number NextUltCharge = 5;
playervar Hero[] ActiveHero = [];
playervar Number[] HeroEffects = [];
playervar Number[] HeroTexts = [];
playervar Number[] HeroHealthPools = [];
playervar Number[] HeroDamageModifications = [];
playervar Number[] HeroHealingModifications = [];

/* ======================================================== */

Vector CenterPosition(Player player = EventPlayer()): (player.EyePosition() + player.Position()) / 2;

Boolean StoppedBeingHero(Player player = EventPlayer()): WaitUntil(HeroOf(player) != EvaluateOnce(HeroOf(player)) || HeroBeingDuplicated(player) != EvaluateOnce(HeroBeingDuplicated(player)), 9999);

Boolean UsingForbiddenAbility(Player player = EventPlayer()): ((IsHero(Hero.Doomfist, player) || IsHero(Hero.Dva, player) || IsHero(Hero.Pharah)) && IsUsingUltimate(player));

Boolean UsingExistingAbility(Player player = EventPlayer()): ((IsHero(Hero.Torbjorn, player) || IsHero(Hero.Sombra, player)) && IsUsingAbility2());

Player GetPlayerTarget(Player player = EventPlayer(), Team team = TeamOf(), RadiusLOS radiusLOS = RadiusLOS.Off, Number angle, Number radius): SortedArray(FilteredArray(PlayersWithinRadius(EyePosition(player), radius, team, radiusLOS).Remove(player).Remove(AllDeadPlayers()), IsInViewAngle(player, ArrayElement(), angle) && !UsingForbiddenAbility(ArrayElement())), AngleBetweenVectors(FacingDirectionOf(player), DirectionTowards(player.EyePosition(), (<Player>ArrayElement()).EyePosition())) + DistanceBetween(player.EyePosition(), (<Player>ArrayElement()).EyePosition())).First;

void InitialHeroSetup(in Hero hero) {
    WaitUntil(CountOf(ActiveHero) == 0, 9999);
    AbortIf(ArrayContains(ActiveHero, hero));
    Wait();
    ModifyVariable(ActiveHero, Operation.AppendToArray, hero);
}

void CleanupEffects() playervar '[all.del] Subroutine: Cleanup Effects' {
    // Cleanup effects
    foreach (Number effectID in HeroEffects) {
        DestroyEffect(effectID);
    }

    HeroEffects = [];
}

void CleanupHealthPools() playervar '[all.del] Subroutine: Cleanup Health Pool' {
    // Cleanup health pool
    foreach (define healthPool in HeroHealthPools) {
        RemoveHealthPoolFromPlayer(healthPool);
    }

    HeroHealthPools = [];
}

void CleanupTexts() playervar '[all.del] Subroutine: Cleanup Texts' {
    // Cleanup texts
    foreach (Number textID in HeroTexts) {
        DestroyHudText(textID);
        DestroyInWorldText(textID);
    }

    HeroTexts = [];
}

void CleanupDamageMods() playervar '[all.del] Subroutine: Cleanup Damage Modifications' {
    // Cleanup texts
    foreach (Number modificationID in HeroDamageModifications) {
        StopDamageModification(modificationID);
    }

    HeroDamageModifications = [];
}

void CleanupHealingMods() playervar '[all.del] Subroutine: Cleanup Healing Modifications' {
    // Cleanup texts
    foreach (Number modificationID in HeroHealingModifications) {
        StopHealingModification(modificationID);
    }

    HeroHealingModifications = [];
}

/* ======================================================== */

rule: "[all.del] Tank Passive: Reduce Ultimate Charge"
Event.OnDamageDealt
if (UltimateChargePercent(Attacker()) < 100)
if (EventAbility() != Button.Ultimate)
if (UltimateChargePercent(Attacker()) > Attacker().NextUltCharge)
if (ArrayContains(AllTankHeroes(), HeroOf(Victim())) || ArrayContains(AllTankHeroes(), HeroBeingDuplicated(Victim())))
{
    SetUltimateCharge(Attacker(), UltimateChargePercent(Attacker()) - Max(1, EventDamage() / 250));
    Attacker().NextUltCharge = UltimateChargePercent(Attacker()) + 5;
}

rule: "[all.del] Reset Tank Passive"
Event.OngoingPlayer
if (UltimateChargePercent() == 0)
{
    NextUltCharge = 5;
}

rule: "[all.del] Tank Passive: Reduced Knockback"
Event.OngoingPlayer
if (ArrayContains(AllTankHeroes(), HeroOf()) || ArrayContains(AllTankHeroes(), HeroBeingDuplicated()))
{
    AbortIf(HeroOf() == Hero.Reinhardt);
    SetKnockbackReceived(EventPlayer(), 70);
    WaitUntil(!ArrayContains(AllTankHeroes(), HeroOf()) && !ArrayContains(AllTankHeroes(), HeroBeingDuplicated()), 9999);
    SetKnockbackReceived(EventPlayer(), 100);
}

rule: "[all.del] Damage Passive"
Event.OngoingPlayer
if (ArrayContains(AllDamageHeroes(), HeroOf()) || ArrayContains(AllDamageHeroes(), HeroBeingDuplicated()))
{
    SetMoveSpeed(EventPlayer(), 115);
    WaitUntil((!ArrayContains(AllDamageHeroes(), HeroOf()) && !ArrayContains(AllDamageHeroes(), HeroBeingDuplicated())) || (HeroOf() == Hero.Echo && IsDuplicating() && !ArrayContains(AllDamageHeroes(), HeroBeingDuplicated())), 9999);
    SetMoveSpeed(EventPlayer(), 100);
    WaitUntil((HeroOf() == Hero.Echo && !IsDuplicating()) || !ArrayContains(AllDamageHeroes(), HeroOf()), 9999);
    LoopIf(HeroOf() == Hero.Echo && !IsDuplicating());
}

rule: "[all.del] Support Passive"
Event.OnDamageTaken
if (ArrayContains(AllSupportHeroes(), HeroOf()) || ArrayContains(AllSupportHeroes(), HeroBeingDuplicated()))
{
    StopHealOverTime(SupportHealingID);
    Wait(2, WaitBehavior.RestartWhenTrue);
    StartHealOverTime(EventPlayer(), EventPlayer(), 9999, 10);
    SupportHealingID = LastHealOverTime();
}

rule: "[all.del] Stop Support Passive"
Event.OngoingPlayer
if ((!ArrayContains(AllSupportHeroes(), HeroOf()) && !ArrayContains(AllSupportHeroes(), HeroBeingDuplicated())) || NormalizedHealth() == 1)
{
    StopHealOverTime(SupportHealingID);
}