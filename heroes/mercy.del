enum MercyVars {
    HealingPercents,
    DegenerationEnabled,
    LastMercyTarget,
    AngelicBlessingTarget,
    AngelicBlessingFlyTarget,
    AngelicBlessings,
    Superjumping,
    AngelicBlessingTextID,
    AngelicBlessingConfirmID
}

playervar Vector AngelicBlessingPosition;

Player GetAngelicBlessingFlyTarget(): GetPlayerTarget(player: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]), radiusLOS: RadiusLOS.Surfaces, angle: 70, radius: 30);

/* ======================================================== */

void CleanupMercy() playervar '[mercy.del] Subroutine: Cleanup' {
    StoppedBeingHero();

    CleanupTexts();
    CleanupHealingMods();
    CleanupEffects();
    CleanupVariables();
    StopForcingPlayerOutlines(AllPlayers(), (<Player>HeroVars[MercyVars.AngelicBlessingTarget]));
    SetAbility2Enabled(Enabled: true);
    AllowButton(Button: Button.Ability2);
    AllowButton(Player: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]), Button: Button.Interact);

    Wait();

    HeroActive = null;
}

void InitialMercy() playervar '[mercy.del] Subroutine: Initial' {
    InitialHeroSetup(Hero.Mercy);

    HeroVars[MercyVars.HealingPercents] = [];
    HeroVars[MercyVars.DegenerationEnabled] = [];
    for (define slot = 0; slot < 5; slot++) {
        HeroVars[MercyVars.HealingPercents][slot] = 1;
        HeroVars[MercyVars.DegenerationEnabled][slot] = false;
    }
    for (define slot = 0; slot < 5; slot++)
    {
        StartHealingModification(PlayersInSlot(EvaluateOnce(slot), TeamOf()), EventPlayer(), HeroVars[MercyVars.HealingPercents][EvaluateOnce(slot)] * 100, HealingModificationRev.ReceiversHealersAndHealingPercent);
        ModifyVariable(HeroHealingModifications, Operation.AppendToArray, LastHealingModificationID());

        #BUG: Mercy's degeneration visual showing when the player in slot does not exist
        CreateInWorldText(EntityExists(PlayersInSlot(EvaluateOnce(slot), TeamOf())) ? EventPlayer() : null, <"[<0><1>%]\n", AbilityIconString(Hero.Baptiste, Button.Ability1), HeroVars[MercyVars.HealingPercents][EvaluateOnce(slot)] * 100>, PlayersInSlot(EvaluateOnce(slot), TeamOf()), 1, Clipping.ClipAgainstSurfaces, InworldTextRev.VisibleToPositionAndString);
        ModifyVariable(HeroTexts, Operation.AppendToArray, LastTextID());
    }
    DisallowButton(Button: Button.Ability2);

    # Create Hud
    CreateHudText(EventPlayer(), null, null, <"<0>(<1>)", <" \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n <0>", <"                                                                                                                            <0>", <"                                                                                                                            <0>", IsInAlternateForm() ?"                                                                                             " : "                                                                     ">>>, "Blessing">, Location.Left, 1, Color.White, Color.White, Color.White, HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
    ModifyVariable(HeroTexts, Operation.AppendToArray, LastTextID());

    async! CleanupMercy();
}

void MercyDegenerateBeam() playervar '[mercy.del] Subroutine: Degenerate Healing Beam' {
    HeroVars[MercyVars.HealingPercents][SlotOf(Healee())] = Max(HeroVars[MercyVars.HealingPercents][SlotOf(Healee())] - 0.07, 0.727272727);
    HeroVars[MercyVars.LastMercyTarget] = PlayersInSlot(SlotOf(Healee()), TeamOf());

    Wait(1);
}

void MercyUpdateDegeneration() playervar '[mercy.del] Subroutine: Update Degeneration' {
    Healer().HeroVars[MercyVars.DegenerationEnabled][SlotOf(Healee())] = true;
    Wait(0.9);

    if (Healer().HeroVars[MercyVars.LastMercyTarget] == EventPlayer()) {
        LoopIf(Healer().HeroVars[MercyVars.LastMercyTarget] == EventPlayer() && IsFiringSecondary(Healer()));
    } else {
        LoopIf(GetPlayerTarget(Healer(), TeamOf(Healer()), RadiusLOS.Surfaces, 360, 15) == EventPlayer() && IsFiringSecondary(Healer()));
    }
    Healer().HeroVars[MercyVars.DegenerationEnabled][SlotOf(Healee())] = false;
}

void MercyRegenerateBeam() playervar '[mercy.del] Subroutine: Regenerate Healing Beam' {
    HeroVars[MercyVars.HealingPercents] = IsUsingUltimate() ? MappedArray(HeroVars[MercyVars.HealingPercents], 1) : MappedArray(HeroVars[MercyVars.HealingPercents], HeroVars[MercyVars.DegenerationEnabled][CurrentArrayIndex()] == false ? Min(ArrayElement() + 0.07, 1) : ArrayElement());
    Wait(1);
    LoopIfConditionIsTrue();
}

void MercyClearLastTarget() playervar '[mercy.del] Subroutine: Clear Last Target' {
    WaitUntil((!IsFiringPrimary() && !IsFiringSecondary()) || IsUsingUltimate(), 9999);
    HeroVars[MercyVars.LastMercyTarget] = null;
}

void MercyAngelicBlessing() playervar '[mercy.del] Subroutine: Mercy Angelic Blessing' {
    AbortIf(AbilityCooldown(Button: Button.Ability2) > 0);
    AbortIfImmobile();
    
    # Get target
    HeroVars[MercyVars.AngelicBlessingTarget] = GetPlayerTarget(radiusLOS: RadiusLOS.Surfaces, angle: 70, radius: 30);
    
    # Abort if Target is not valid
    AbortIf((<Player>HeroVars[MercyVars.AngelicBlessingTarget]) == null);

    # Casting
    SetDamageDealt(DamageDealtPercent: 0);
    PressButton(Button: Button.Melee);
    SetAbilityCooldown(Button: Button.Melee, Cooldown: 0);
    AngelicBlessingPosition = EyePosition();
    SetAbility2Enabled(Enabled: false);

    # Team Effects
    CreateEffect(
        VisibleTo: AllPlayers(TeamOf()),
        Type: Effect.Orb,
        Color: Color.Yellow,
        Position: AngelicBlessingPosition,
        Radius: 1,
        Reevaluation: EffectRev.VisibleToPositionAndRadius
    );
    ModifyVariable(HeroEffects, Operation.AppendToArray, LastCreatedEntity());

    # Enemy Effects
    CreateEffect(
        VisibleTo: AllPlayers(OppositeTeamOf(TeamOf()
        )),
        Type: Effect.Orb,
        Color: Color.Orange,
        Position: AngelicBlessingPosition,
        Radius: 1,
        Reevaluation: EffectRev.VisibleToPositionAndRadius
    );
    ModifyVariable(HeroEffects, Operation.AppendToArray, LastCreatedEntity());
    
    Communicate(Type: Communication.Go);
    ChaseVariableAtRate(AngelicBlessingPosition, ((<Player>HeroVars[MercyVars.AngelicBlessingTarget]))
    .EyePosition(), 100, RateChaseReevaluation.DestinationAndRate);

    WaitUntil(DistanceBetween(AngelicBlessingPosition, (<Player>HeroVars[MercyVars.AngelicBlessingTarget]).EyePosition()) < 1, 9999);
    SetDamageDealt(DamageDealtPercent: 100);

    # Angelic Blessing Target
    CreateInWorldText(
        VisibleTo: AllPlayers(),
        Header: <"<0><1>", AbilityIconString(Hero.Mercy, Button.Ability1), StringSlice("\n\n", 0, (IsHero(Hero.Mercy, LocalPlayer()) && (<Player>HeroVars[MercyVars.AngelicBlessingTarget]).Team() == LocalPlayer().Team()) || HasStatus((<Player>HeroVars[MercyVars.AngelicBlessingTarget]), Status.Hacked) ? 2 : 0)>,
        Position: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]),
        Scale: 1.5,
        Clipping: Clipping.ClipAgainstSurfaces,
        Reevaluation: InworldTextRev.VisibleToAndString
    );
    HeroVars[MercyVars.AngelicBlessingTextID] = LastTextID();
    ModifyVariable(HeroTexts, Operation.AppendToArray, HeroVars[MercyVars.AngelicBlessingTextID]);

    # Angelic Blessing Player Hud
    OnScreenText.CreateOnScreenText(
        (<Player>HeroVars[MercyVars.AngelicBlessingTarget]),
        <"Guardian Angel [<0>] |                                | [<0>] Guardian Angel", InputBindingString(Button.Interact)>,
        0,
        0.15,
        1.32
    );
    HeroVars[MercyVars.AngelicBlessingConfirmID] = LastTextID();
    ModifyVariable(HeroTexts, Operation.AppendToArray, HeroVars[MercyVars.AngelicBlessingTextID]);

    SmallMessage((<Player>HeroVars[MercyVars.AngelicBlessingTarget]), <"Angelic Blessing Received by <0>", EventPlayer()>);
    StopChasingVariable(AngelicBlessingPosition);
    CleanupEffects();

    ModifyVariable(HeroVars[MercyVars.AngelicBlessings], Operation.AppendToArray, (<Player>HeroVars[MercyVars.AngelicBlessingTarget]));

    # Team Effects
    CreateEffect(AllPlayers(TeamOf()), Effect.Sparkles, Color.Yellow, (<Player>HeroVars[MercyVars.AngelicBlessingTarget]), 1.5, EffectRev.VisibleTo);
    ModifyVariable(HeroEffects, Operation.AppendToArray, LastCreatedEntity());

    PlayEffect(AllPlayers(TeamOf()), PlayEffect.GoodExplosion, Color.Yellow, AngelicBlessingPosition, 1);

    # Enemy Effects
    CreateEffect(AllPlayers(OppositeTeamOf(TeamOf())), Effect.Sparkles, Color.Orange, (<Player>HeroVars[MercyVars.AngelicBlessingTarget]), 1.5, EffectRev.VisibleTo);
    ModifyVariable(HeroEffects, Operation.AppendToArray, LastCreatedEntity());

    PlayEffect(AllPlayers(OppositeTeamOf(TeamOf())), PlayEffect.GoodExplosion, Color.Orange, AngelicBlessingPosition, 1);

    # Effects
    CreateEffect((<Player>HeroVars[MercyVars.AngelicBlessingTarget]), Effect.HealTargetEffect, <Color>TeamOf((<Player>HeroVars[MercyVars.AngelicBlessingTarget])), (<Player>HeroVars[MercyVars.AngelicBlessingTarget]), 1, EffectRev.VisibleTo);
    ModifyVariable(HeroEffects, Operation.AppendToArray, LastCreatedEntity());

    PlayEffect(AllPlayers(), PlayEffect.BuffExplosionSound, Color.White, AngelicBlessingPosition, 100);

    # Stop casting
    AngelicBlessingPosition = null;
    SetAbilityCooldown(Button: Button.Ability2, Cooldown: 12);
    SetAbility2Enabled(Enabled: true);
    DisallowButton(Player: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]), Button: Button.Interact);

    # Wait until target chooses to fly to a target, after 6 seconds have elapsed, or if the target is using an ability that restricts their movement
    WaitUntil(((<Player>HeroVars[MercyVars.AngelicBlessingTarget]).IsButtonHeld(Button.Interact) && GetAngelicBlessingFlyTarget() && !UsingForbiddenAbility((<Player>HeroVars[MercyVars.AngelicBlessingTarget]))) || HeroBeingDuplicated((<Player>HeroVars[MercyVars.AngelicBlessingTarget])) != EvaluateOnce(HeroBeingDuplicated((<Player>HeroVars[MercyVars.AngelicBlessingTarget]))) || MaxHealth((<Player>HeroVars[MercyVars.AngelicBlessingTarget])) != EvaluateOnce(MaxHealth((<Player>HeroVars[MercyVars.AngelicBlessingTarget]))), 6);

    HeroVars[MercyVars.Superjumping] = IsCrouching((<Player>HeroVars[MercyVars.AngelicBlessingTarget])) ? true : false;
    HeroVars[MercyVars.AngelicBlessingFlyTarget] = GetAngelicBlessingFlyTarget();
    
    # Cleanup
    DestroyInWorldText(HeroVars[MercyVars.AngelicBlessingConfirmID]);
    DestroyInWorldText(HeroVars[MercyVars.AngelicBlessingTextID]);
    StopForcingPlayerOutlines(AllPlayers(), (<Player>HeroVars[MercyVars.AngelicBlessingTarget]));
    CleanupEffects();

    # Effects
    CreateEffect(AllPlayers(), Effect.Soldier76SprintingEffect, Color.White, (<Player>HeroVars[MercyVars.AngelicBlessingTarget]), 1, EffectRev.VisibleTo);
    ModifyVariable(HeroEffects, Operation.AppendToArray, LastCreatedEntity());

    # If there is a valid fly target and the player isn't using an ability that restricts their movement, we GA
    if ((<Player>HeroVars[MercyVars.AngelicBlessingTarget]).IsButtonHeld(Button.Interact))
    {
        AbortIf(!EntityExists(HeroVars[MercyVars.AngelicBlessingFlyTarget]));
        AbortIfImmobile();
        AbortIf(UsingForbiddenAbility((<Player>HeroVars[MercyVars.AngelicBlessingTarget])));

        PlayEffect(AllPlayers(), PlayEffect.BuffExplosionSound, Color.White, AngelicBlessingPosition, 100);
        SetGravity((<Player>HeroVars[MercyVars.AngelicBlessingTarget]), 0);
        SetJumpVerticalSpeed((<Player>HeroVars[MercyVars.AngelicBlessingTarget]), 0);
        SetStatus((<Player>HeroVars[MercyVars.AngelicBlessingTarget]), null, Status.Rooted, 9999);

        Vector Direction = DirectionTowards((<Player>HeroVars[MercyVars.AngelicBlessingTarget]).Position(), PositionOf(HeroVars[MercyVars.AngelicBlessingFlyTarget]));

        # Cancel any movement the player has
        ApplyImpulse(
            Player: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]),
            Direction: VelocityOf((<Player>HeroVars[MercyVars.AngelicBlessingTarget])),
            Speed: -HorizontalSpeedOf((<Player>HeroVars[MercyVars.AngelicBlessingTarget])),
            Motion: ContraryMotion.Incorporate
        );

        # If the player is not superjumping or on the ground, we lift them up slightly to simulate GA
        SkipIf(IsInAir((<Player>HeroVars[MercyVars.AngelicBlessingTarget])) || HeroVars[MercyVars.Superjumping], 1);
        ApplyImpulse(
            Player: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]),
            Direction: Up(),
            Speed: 1,
            Motion: ContraryMotion.Incorporate
        );

        # If the player is superjumping or in the air, we push them down slightly to simulate GA
        SkipIf(IsInAir((<Player>HeroVars[MercyVars.AngelicBlessingTarget])) || !HeroVars[MercyVars.Superjumping], 1);
        ApplyImpulse(
            Player: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]),
            Direction: Down(),
            Speed: 1,
            Motion: ContraryMotion.Incorporate
        );

        Wait();

        while (DistanceBetween((<Player>HeroVars[MercyVars.AngelicBlessingTarget]).Position(), PositionOf(HeroVars[MercyVars.AngelicBlessingFlyTarget])) > 2) 
        {
            AbortIf(UsingForbiddenAbility((<Player>HeroVars[MercyVars.AngelicBlessingTarget])));

            # Impulse loop while the player isn't close to the fly target, isn't using any ability that restricts their movement, or hasn't jumped.
            ApplyImpulse(
                Player: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]),
                Direction: Direction,
                Speed: LinearInterpolate(0, 17, Min(1, DistanceBetween((<Player>HeroVars[MercyVars.AngelicBlessingTarget]).Position(), PositionOf(HeroVars[MercyVars.AngelicBlessingFlyTarget])) / 10)),
                Motion: ContraryMotion.CancelXYZ
            );
            # This impulse allows us to slow down the player as they approach their target to simulate GA
            ApplyImpulse(
                Player: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]),
                Direction: Direction,
                Speed: -1 * LinearInterpolate(17, 0, Min(1, DistanceBetween((<Player>HeroVars[MercyVars.AngelicBlessingTarget]).Position(), PositionOf(HeroVars[MercyVars.AngelicBlessingFlyTarget])) / 10)),
                Motion: ContraryMotion.Incorporate
            );

            # If the player is within range of superjumping and jumps, we launch them up
            if ((<Player>HeroVars[MercyVars.AngelicBlessingTarget]).IsButtonHeld(Button.Jump) && DistanceBetween((<Player>HeroVars[MercyVars.AngelicBlessingTarget]).Position(), PositionOf(HeroVars[MercyVars.AngelicBlessingFlyTarget])) < 4 && HeroVars[MercyVars.Superjumping]) {
                ApplyImpulse(
                    Player: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]),
                    Direction: Up(),
                    Speed: 8.5,
                    Motion: ContraryMotion.Incorporate
                );
            }

            # If the player jumps at any point during the GA, retain momentum and send them forward
            if ((<Player>HeroVars[MercyVars.AngelicBlessingTarget]).IsButtonHeld(Button.Jump)) {
                ApplyImpulse(
                    Player: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]),
                    Direction: Direction + (Up() / 4),
                    Speed: 24,
                    Motion: ContraryMotion.Incorporate
                );

                break;
            }

            # If there is no line of sight or the player flies past the target, break the loop
            if (TotalTimeElapsed() % 1 <= 0.08)
            {
                if (
                    !IsInLineOfSight(
                        (<Player>HeroVars[MercyVars.AngelicBlessingTarget]).EyePosition(), 
                        (<Player>HeroVars[MercyVars.AngelicBlessingTarget]).EyePosition() + DirectionTowards((<Player>HeroVars[MercyVars.AngelicBlessingTarget]).Position(), EvaluateOnce(PositionOf(HeroVars[MercyVars.AngelicBlessingFlyTarget])))
                    ) ||
                    DotProduct(Direction, DirectionTowards((<Player>HeroVars[MercyVars.AngelicBlessingTarget]).Position(), PositionOf(HeroVars[MercyVars.AngelicBlessingFlyTarget]))) < 0
                ) {
                    break;
                }
            }

            Wait(0.08);
        }
    }

    # Cleanup
    SetGravity((<Player>HeroVars[MercyVars.AngelicBlessingTarget]), 100);
    SetJumpVerticalSpeed((<Player>HeroVars[MercyVars.AngelicBlessingTarget]), 100);
    AllowButton(Player: (<Player>HeroVars[MercyVars.AngelicBlessingTarget]), Button: Button.Interact);
    ClearStatus((<Player>HeroVars[MercyVars.AngelicBlessingTarget]), Status.Rooted);
    HeroVars[MercyVars.AngelicBlessingTarget] = null;
    HeroVars[MercyVars.AngelicBlessingFlyTarget] = null;
    StopForcingPlayerOutlines(AllPlayers(), (<Player>HeroVars[MercyVars.AngelicBlessingTarget]));
    ModifyVariable(HeroTexts, Operation.RemoveFromArrayByValue, HeroVars[MercyVars.AngelicBlessingTextID]);
    CleanupEffects();
}

void MercyAngelicBlessingOutline() playervar '[mercy.del] Subroutine: Update Mercy Angelic Blessing Player Target Outline' {
    Wait(0.032, WaitBehavior.AbortWhenFalse);
    StopForcingPlayerOutlines(AllPlayers().Remove(GetAngelicBlessingFlyTarget()), (<Player>HeroVars[MercyVars.AngelicBlessingTarget]));
    StartForcingPlayerOutlines(GetAngelicBlessingFlyTarget(), (<Player>HeroVars[MercyVars.AngelicBlessingTarget]), true, Color.Yellow, OutlineType.Always);
    LoopIfConditionIsTrue();
    StopForcingPlayerOutlines(AllPlayers(), (<Player>HeroVars[MercyVars.AngelicBlessingTarget]));
}

/* ======================================================== */

rule: '[mercy.del] Initial'
Event.OngoingPlayer
Player.Mercy
{
    InitialMercy();
}

rule: '[mercy.del] Degenerate Healing Beam'
Event.OnHealingDealt
Player.Mercy
if (EventHealing() > 0)
if (Healer() != Healee())
if (!IsUsingUltimate())
{
    MercyDegenerateBeam();
}

rule: '[mercy.del] Regenerate Healing Beam'
Event.OngoingPlayer
Player.Mercy
{
    MercyRegenerateBeam();
}

rule: '[mercy.del] Update Degeneration'
Event.OnHealingTaken
if (HeroOf(Healer()) == Hero.Mercy || HeroBeingDuplicated(Healer()) == Hero.Mercy)
if (Healer() != Healee())
if (!IsUsingUltimate(Healer()))
{
    MercyUpdateDegeneration();
}

rule: '[mercy.del] Clear Last Target'
Event.OngoingPlayer
Player.Mercy
if (!IsUsingUltimate())
if (IsFiringSecondary())
{
    MercyClearLastTarget();
}

rule: '[mercy.del] Angelic Blessing'
Event.OngoingPlayer
Player.Mercy
if (IsButtonHeld(Button: Button.Ability2))
{
    MercyAngelicBlessing();
}

rule: '[mercy.del] Update Angelic Blessing Player Target Outline'
Event.OngoingPlayer
Player.Mercy
if ((<Player>HeroVars[MercyVars.AngelicBlessingTarget]) && !HeroVars[MercyVars.AngelicBlessingFlyTarget])
{
    MercyAngelicBlessingOutline();
}

/* ======================================================== */

rule: '[mercy.del] Initial (Duplication)'
Event.OngoingPlayer
Player.Echo
if (HeroBeingDuplicated() == Hero.Mercy)
{
    InitialMercy();
}

rule: '[mercy.del] Degenerate Healing Beam (Duplication)'
Event.OnHealingDealt
Player.Echo
if (EventHealing() > 0)
if (HeroBeingDuplicated() == Hero.Mercy)
if (Healer() != Healee())
if (!IsUsingUltimate())
{
    MercyDegenerateBeam();
}

rule: '[mercy.del] Regenerate Healing Beam (Duplication)'
Event.OngoingPlayer
Player.Echo
if (HeroBeingDuplicated() == Hero.Mercy)
{
    MercyRegenerateBeam();
}

rule: '[mercy.del] Clear Last Target (Duplication)'
Event.OngoingPlayer
Player.Echo
if (HeroBeingDuplicated() == Hero.Mercy)
if (!IsUsingUltimate())
if (IsFiringSecondary())
{
    MercyClearLastTarget();
}

rule: '[mercy.del] Angelic Blessing (Duplication)'
Event.OngoingPlayer
Player.Echo
if (HeroBeingDuplicated() == Hero.Mercy)
if (IsButtonHeld(Button: Button.Ability2))
{
    MercyAngelicBlessing();
}

rule: '[mercy.del] Update Angelic Blessing Player Target Outline (Duplication)'
Event.OngoingPlayer
Player.Echo
if (HeroBeingDuplicated() == Hero.Mercy)
if ((<Player>HeroVars[MercyVars.AngelicBlessingTarget]) && !HeroVars[MercyVars.AngelicBlessingFlyTarget])
{
    MercyAngelicBlessingOutline();
}